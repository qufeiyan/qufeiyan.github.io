<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode刷题之15.md]]></title>
    <url>%2Fpost%2F4163df04.html</url>
    <content type="text"><![CDATA[三数之和 给定一个包含n个整数的nums,判断nums中是否存在三个元素a、b、c，使得1a + b + c = 0 找出所有满足条件且不重复的三元组。 注意: 答案中不可以包含重复的三元组。 123456例如，给定数组 nums = [-1,0,1,2,-1,-4],满足要求的三元组集合为：[ [-1,0,1] [-1,-1,2]] 思路 用双指针法求解。 首先对数组进行升序排列，从第一个数开始遍历，若该数大于0，则无解。否则该数可能满足条件，定义前后两个指针l、r，判断nums[l]+nums[r]+nums[i]是否等于0,若=0,加入解集；若&gt;0，说明nums[l]+nums[r]过大，则向前移动后指针，即r–；反之，说明nums[l]+nums[r]较小，则需要向后移动前指针，即l++。 解决重复问题 由于数组已经升序排列，只需要判断相邻两个数是否相等，如果相等则移动指针。 实现代码：C++12345678910111213141516171819202122232425262728293031323334class Solution&#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums)&#123; vector&lt;vector&lt;int&gt;&gt; res; int size = nums.size(); if(size &lt; 3)&#123; return res; &#125; sort(nums.begin(),nums.end()); for(int i = 0; i &lt; size; i++)&#123; if(nums[i] &gt; 0)&#123; break; &#125; if(i&gt;0 &amp;&amp; nums[i] == nums[i-1])&#123; continue; &#125; int l = i+1,r = size-1; while(l &lt; r)&#123; int sum = nums[i] + nums[l] + nums[r]; if(sum = 0)&#123; res.insert(&#123;nums[i],nums[l],nums[r]&#125;); while(l &lt; r &amp;&amp; nums[l] == nums[l+1] ) l++; while(l &lt; r &amp;&amp; nums[r] == nums[r-1]) r--; l++; r--; &#125;else if(sum &lt; 0)&#123; l++; &#125;else r--; &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题之14.md]]></title>
    <url>%2Fpost%2Ff9dfb861.html</url>
    <content type="text"><![CDATA[题目 编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串””。 示例112输入： ["flower","flow","flight"]输出： "fl" 示例2123输入： ["dog","racecar","car"]输出： ""解释： 输入不存在公共前缀 说明所有输入只包含小写字母a-z； 实现代码：C++12345678910111213141516171819202122232425262728class Solution&#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs)&#123; int size = strs.size(); if(size == 0)&#123; return ""; &#125; string temp; bool flag = false; for(int j = 0; j &lt; strs[0].size(); j++)&#123; char t = strs[0][j]; for(int i = 0; i &lt; size; i++)&#123; if(strs[i][j] != t || strs[i][j == '\0'])&#123; flag = true; break; &#125; &#125; if(flag)&#123; break; &#125; temp.push_back(t); &#125; return temp; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之Bridge模式]]></title>
    <url>%2Fpost%2F2af670e6.html</url>
    <content type="text"><![CDATA[Bridge 模式存在之意图:“将抽象与现实解耦，使它们可以独立地变化”。 Bridge 模式是最难理解的模式，部分原因是它功能非常强大，适用于多种场合。而且，它还与常见的用继承来处理特殊情况的方式背道而驰。但是，它却是一个遵循设计模式社区两大原则的极好例子：“找出变化并封装之”和“优先使用对象聚集，而不是类继承”。 需求特点： 概念的抽象有变化； 这些概念的实现方式有变化。 要点：在需求定义期间，应该尽早而且经常地考虑变化。 UML类图如下： 问题：一个抽象类的派生类必须使用多个实现，但它不能出现类数量爆炸性增长。 解决方案：为所有实现定义一个接口，供抽象类的所有派生类使用。 参与者与协作者：Abstraction为要实现的对象定义接口，Implementor为具体的实现类定义接口。Abstraction的派生类使用Implementor的派生类，却无需知道自己具体使用哪一个ConcreteImplementor。 效果：实现与使用实现的对象解耦，提供了可扩展性，客户对象无需操心实现问题。 代码示例：假设目前有这么几个类:GoogleTV 和 AppleTV,都能实现换台，与开关电视等基本功能，但是并没有一个统一的接口，用户其实也不care你用的是哪个TV，用户只是单纯想看芒果台而已。现在使用Bridge模式实现这个需求。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public interface TV&#123; public void powerON(); public void powerOff(); public void changeChannel(int channel);&#125;public class GoogleTV implements TV&#123; public void powerOn()&#123;&#125; public void powerOff()&#123;&#125; public void changeChannel(int channel)&#123;&#125;&#125;public class AppleTV implements TV&#123; public void powerOn()&#123;&#125; public void powerOff()&#123;&#125; public void changeChannel(int channel)&#123;&#125;&#125;public abstract class TVRemoteControl&#123; private TV tv; public void setTV(TV tv)&#123; this.tv = tv; &#125; public TV getTV()&#123; return this.tv; &#125; public void powerOn()&#123; implementor.powerOn(); &#125; public void powerOff()&#123; implementor.powerOff(); &#125; public void setChannel(int channel)&#123; implementor.changeChannel(channel); &#125;&#125;public class ConcreteTVRemoteControl extends TVRemoteControl&#123; private int currentChannel; public void nextChannel()&#123; currentChannel++; setChannel(currentChannel); &#125; public void prevChannel()&#123; currentChannel++; setChannel(currentChannel); &#125;&#125;public class BridgeTest &#123; public static void main(String[] args) &#123; TVRemoteControl tvBridge = new TVRemoteControl(); /*使用google TV */ GoogleTV googleTV = new GoogleTV(); tvBridge.setTV(googleTV); tvBridge.setChannel(3); /*使用 Apple TV */ GoogleTV googleTV = new GoogleTV(); tvBridge.setTV(googleTV); tvBridge.setChannel(3); &#125;&#125; 可结合 Strategy、 Adapter 模式来看。]]></content>
      <categories>
        <category>编程思想</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之Proxy模式]]></title>
    <url>%2Fpost%2Fae91a8e6.html</url>
    <content type="text"><![CDATA[Proxy 模式意图 为其他对象提供一种代理以控制对这个对象的访问。 动机 对一个对象进行访问控制的一个原因是为了只有在我们确实需要这个对象时才对它进行创建和初始化。 应用场景 代理模式主要用于当我们需要一个简单对象来表示一个复杂对象的情形。如果创建对象的开销很大，那么可以==推迟其创建==，并使用一个简单对象来代理其功能直到必须立即创建的时候。这个简单对象就可以称为复杂对象的代理。 UML类图如下： 参与者与协作者： 抽象角色（Subject）：它是一个由真实角色实现的接口，并能够表征真实角色的功能。该接口同时也必须由代理角色实现，这样代理角色能够用于所有真实角色所能使用的地方。 代理角色（Proxy）：它维护了能够允许代理角色访问真实角色的引用。代理角色与真实角色都实现了同一个接口，这样代理角色就能代替真实角色，实现对真实角色的访问控制并负责数据的创建和删除。根据代理的类型，其还能负责其他的职责。 真实角色（RealSubject）：这是代理角色所代表的真实对象。 代码示例:假如我们想要在电子邮件中附加一张图片。而添加一张照片并发送是一件耗费大量资源的操作。 这时我们使用代理模式，让我们能够在确实需要加载图片时才对它进行创建和初始化。 首先，我们创建一个能够被真实对象和代理对象实现的通用接口 123public interface Image &#123; void showImage();&#125; 建立一个真实图片类实现上述接口 123456789101112131415161718public class RealImage implements Image &#123; private URL url; public RealImage(URL url)&#123; this.url = url; loadImage(url); &#125; @Override public void showImage() &#123; System.out.println("Displaying " + url.getFile()); &#125; private void loadImage(URL url)&#123; System.out.println("Loading " + url.getFile()); &#125;&#125; 编写代理类，提供对真实图片类的访问。 1234567891011121314151617public class ProxyImage implements Image&#123; private RealImage realImage; private URL url; public ProxyImage(URL url)&#123; this.url = url; &#125; @Override public void showImage() &#123; if(realImage == null)&#123; realImage = new RealImage(url); &#125; realImage.showImage(); &#125;&#125; 测试 123456789101112public class ProxyTest &#123; public static void main(String[] args) &#123; Image image = new ProxyImage(new URL("test.jpeg")); // 加载图片 image.showImage(); System.out.println(""); // 图像加载过，则不需再次加载 image.showImage(); &#125;&#125;]]></content>
      <categories>
        <category>编程思想</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fpost%2F4a17b156.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hhhh</category>
      </categories>
      <tags>
        <tag>hh</tag>
      </tags>
  </entry>
</search>
