<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode之合并两个有序链表]]></title>
    <url>%2Fpost%2F5fd4a75a.html</url>
    <content type="text"><![CDATA[题目 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例：12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 分析 归并排序，原理与 合并两个有序数组相似。 实现代码：C++1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode *dummyHead = new ListNode(0); ListNode *temp = dummyHead; ListNode *i = l1,*j = l2; while(i &amp;&amp; j)&#123; if(i-&gt;val &lt; j-&gt;val)&#123; temp-&gt;next = i; temp = temp-&gt;next; i = i-&gt;next; &#125;else&#123; temp-&gt;next = j; temp = temp-&gt;next; j = j-&gt;next; &#125; &#125; temp-&gt;next = i ? i : j; return dummyHead-&gt;next; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>链表</tag>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode之两数相加(2)]]></title>
    <url>%2Fpost%2Fa010aa05.html</url>
    <content type="text"><![CDATA[题目 给定两个非空链表来表示两个非负整数。位数按照逆序方式存储,它们的每个节点只存储单个数字。将两数相加返回一个新的链表。 你可以假设除了数字 0 之外，这两个数字都不会以零开头。 示例：123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 分析 如上图示： 首先考虑两个数的位数，假设俩数位数不一致，为了能够更新新链表，可将不足位数补0。 其次考虑进位问题，若进位发生在最后一位之前，即没有产生新的位数，设置 carry 位，每次相加时候加上上次相加结果的carry , 即 sum = (x + y + carry)%10即为新链表的位数，然后利用 carry = (x + y + carry)/10更新carry。 若最后一次相加产生进位，则表示产生新位数，需要新建结点附在新链表后面。 我们使用哑结点来简化代码。如果没有哑结点，则必须编写额外的条件语句来初始化表头的值。 实现代码：C++123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode* dummyNode = new ListNode(0); ListNode* temp = dummyNode; int carry = 0; while(l1 || l2)&#123; ListNode* newNode = new ListNode(0); int x = l1 ? l1-&gt;val : 0; int y = l2 ? l2-&gt;val : 0; newNode-&gt;val = (x+y+carry)%10; carry = (x+y+carry)/10; if(l1 != NULL) l1 = l1-&gt;next; if(l2 != NULL) l2 = l2-&gt;next; temp-&gt;next = newNode; temp = temp-&gt;next; &#125; if(carry &gt; 0) temp-&gt;next = new ListNode(carry); return dummyNode-&gt;next; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>链表</tag>
        <tag>哑结点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode之反转链表(206)]]></title>
    <url>%2Fpost%2F4a74759.html</url>
    <content type="text"><![CDATA[题目 反转一个单链表。 示例:12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 进阶: 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 分析 迭代法 如图所示，初始化一个newHead指针，用来作为反转后链表的头。第一次迭代时，将原来的 head 指针的后继，即 head-&gt;next作为新一轮的 head，并将 newHead 更新为原来的 head,原来 head 的后继变为其前驱，即更新前的newHead。为防止 head 丢失，应设一个 temp指针保存当前的 head。 实现代码：C++1234567891011121314151617181920212223/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if(head == NULL || head-&gt;next == NULL) return head; ListNode* newHead = NULL; while(head)&#123; ListNode* temp = head; head = head-&gt;next; temp-&gt;next = newHead; newHead = temp ; &#125; return newHead; &#125;&#125;; 递归法 迭代法是从前往后更新链表，递归法则从后往前倒推。如下图示。 在最后一级递归中，按照递归终止条件，返回的是表尾，而此时，对应的表头节点为 head-&gt;next,然后进行反转操作。反转单个节点：将(``head->next``)的后继指针（``head->next->next``）变为其前驱(``head``)。并断开其原先的前驱。12345678910111213141516171819202122# 实现代码：C++``` C++/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if(head == NULL || head-&gt;next == NULL) return head; ListNode* newHead = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-next = NULL; return newHead; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>迭代/递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode之合并两个有序数组（88）]]></title>
    <url>%2Fpost%2F5d771dc9.html</url>
    <content type="text"><![CDATA[题目 给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 示例:12345输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3输出: [1,2,2,3,5,6] 分析 有序数组为升序。 实现代码：C++12345678910111213141516class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; vector&lt;int&gt; nums(m+n); int i = 0, j = 0, k = 0; while(i&lt;m &amp;&amp; j&lt;n)&#123; if(nums1[i] &lt; nums2[j])&#123; nums[k++] = nums1[i++]; &#125;else nums[k++] = nums2[j++]; &#125; while(i &lt; m) nums[k++] = nums1[i++]; while(j &lt; n) nums[k++] = nums2[j++]; nums1.assign(nums.begin(),nums.end()); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Tencent</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeeCode之盛最多水的容器（11）]]></title>
    <url>%2Fpost%2F46a7e20d.html</url>
    <content type="text"><![CDATA[题目 给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例12输入: [1,8,6,2,5,4,8,3,7]输出: 49 分析 定义l、r两个指针分别指向数组的左右两端，然后向中间搜索。 如上图示，容器面积取决于最短的线。则每次面积更新公式为 min(height[l],height[r])*(r-i)。 每次更新指针时，固定长线，移动短线。 实现代码：C++123456789101112131415class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int res = 0; int l = 0,r = height.size()-1; while(l &lt; r)&#123; res = max(res,min(height[l],height[r])*(r-l)); if(height[l]&lt;height[r])&#123; l++; &#125;else r--; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Tencent</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>双指针法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode之字符串转整数(atoi)（8）]]></title>
    <url>%2Fpost%2F8d9f4efd.html</url>
    <content type="text"><![CDATA[题目 实现 atoi，将字符串转为整数。 在找到第一个非空字符之前，需要移除掉字符串中的空格字符。如果第一个非空字符是正号或负号，选取该符号，并将其与后面尽可能多的连续的数字组合起来，这部分字符即为整数的值。如果第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 字符串可以在形成整数的字符后面包括多余的字符，这些字符可以被忽略，它们对于函数没有影响。 当字符串中的第一个非空字符序列不是个有效的整数；或字符串为空；或字符串仅包含空白字符时，则不进行转换。 若函数不能执行有效的转换，返回 0。 说明： 假设我们的环境只能存储 32位 有符号整数，其数值范围是 $[−2^{31}$, $2^{31} − 1]$。如果数值超过可表示的范围，则返回 INT_MAX ($2^{31} − 1$) 或 INT_MIN ($−2^{31}$) 。 示例 1:123输入: "42"输出: 42示例 2: 示例 2:1234输入: " -42"输出: -42解释: 第一个非空白字符为 '-', 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 示例 3:123输入: "4193 with words"输出: 4193解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。 示例 4:1234输入: "words and 987"输出: 0解释: 第一个非空字符是 'w', 但它不是数字或正、负号。 因此此无法执行有效的转换。 示例 5:1234输入: "-91283472332"输出: -2147483648解释: 数字 "-91283472332" 超过 32 位有符号整数范围。 因此返回 INT_MIN。 分析 先去除字符串开头空格。 用第一个字符，判断正负。 数字字符换成数字，可以直接用该字符-‘0’。 每一位的获取可以用上一次结果x10+当前转换后的数字。 实现代码：C++1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int myAtoi(string str) &#123; str.erase(0,str.find_first_not_of(" ")); int size = str.size(); if(size &lt; 1)&#123; return 0; &#125; long res = 0; char first; bool isPositive = true; // const int INT_MAX = 2^31; for(int i = 0;i &lt; size;i++)&#123; char c = str[i]; if(i == 0 &amp;&amp; (c == '+' || c == '-'))&#123; isPositive = (c == '+'); &#125;else if(c &gt;= '0' &amp;&amp; c &lt;= '9')&#123; res *= 10; res += c - '0'; long actual = isPositive ? res : -res; if(actual &gt; INT_MAX)&#123; return INT_MAX; &#125;else if(actual &lt; INT_MIN)&#123; return INT_MIN; &#125; &#125;else&#123; return isPositive ? (int)res : (int)-res; &#125; &#125; return isPositive ? (int)res : (int)-res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>去字符串空格</tag>
        <tag>数字字符转数字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode之最长回文子串（5）]]></title>
    <url>%2Fpost%2Feef3535.html</url>
    <content type="text"><![CDATA[题目 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。 示例 1：123输入: "babad"输出: "bab"注意: "aba"也是一个有效答案。 示例 2：12输入: "cbbd"输出: "bb" 分析 用动态规划思想求解。用DP(i,j)表示从i到j的子串，若回文值为true，否则为false。 根据回文的特点，可得如下状态转移方程：123i = j时，DP(i,j) = true;i = j+1时，DP(i,j) = (str[i] == str[j])i &gt; j+1时，DP(i,j) = (str[i] == str[j] &amp;&amp; DP(i+1,j-1)) 实现代码：C++123456789101112131415161718192021222324252627class Solution &#123;public: string longestPalindrome(string s) &#123; int size = s.size(); if(size == 0)&#123; return ""; &#125; int maxSize = 1; int start = 0; bool DP[size][size]; for(int j = 0;j &lt; size;j++)&#123; for(int i = 0;i &lt;= j;i++)&#123; if(j &lt;= i+1)&#123; DP[i][j] = (s[i]==s[j]); &#125;else&#123; DP[i][j] = (s[i]==s[j] &amp;&amp; DP[i+1][j-1]); &#125; if(DP[i][j] &amp;&amp; maxSize &lt; j-i+1)&#123; maxSize = j-i+1; start = i; &#125; &#125; &#125; return s.substr(start,maxSize); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>字符串</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode之两数之和（1）]]></title>
    <url>%2Fpost%2F49926507.html</url>
    <content type="text"><![CDATA[题目 给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。 示例：1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 分析 利用 哈希表 存储数组的元素值与相应下标。将问题转化为查找表中是否存在满足 target - nums[i]的键即可。 实现代码：C++12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; int size = nums.size(); vector&lt;int&gt; res; if(size &lt; 2)&#123; return res; &#125; unordered_map&lt;int,int&gt; umap; for(int i=0;i&lt;size;i++)&#123; umap[nums[i]] = i; &#125; for(int i=0;i&lt;size;i++)&#123; int t = target - nums[i]; if(umap.count(t) &amp;&amp; umap[t] != i)&#123; res.push_back(i); res.push_back(umap[t]); break; &#125; &#125; return res; &#125;&#125;; 复杂度分析 时间复杂度：O(n)， 我们把包含有 n 个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1)，所以时间复杂度为 O(n)。 空间复杂度：O(n)， 所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 n 个元素。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>算法</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode之四数之和（18）]]></title>
    <url>%2Fpost%2Fca2c8b0b.html</url>
    <content type="text"><![CDATA[题目 给定一个包含 n 个整数的数组 nums 和一个目标值 target ，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 注意： 答案中不可以包含重复的四元组。 示例：12345678给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。满足要求的四元组集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 分析 思路与 三数之和 相同。利用双指针法，在三数之和基础上再加上一层循环。即可实现 四数之和。 实现代码：C++12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; int size = nums.size(); if(size &lt; 4)&#123; return res; &#125; sort(nums.begin(),nums.end()); for(int i = 0; i &lt; size - 3 ; i++)&#123; for(int j = i+1; j &lt; size - 2 ; j++)&#123; if((i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) || (j &gt; i + 1 &amp;&amp; nums[j] == nums[j-1]))&#123; continue; &#125; int l = j+1, r= size - 1; while(l &lt; r)&#123; int sum = nums[i] + nums[j] + nums[l] + nums[r]; if(sum == target)&#123; // res.insert(res.begin(),&#123; nums[i],nums[j],nums[l],nums[r]&#125;); res.push_back(&#123; nums[i],nums[j],nums[l],nums[r]&#125;); while(l &lt; r &amp;&amp; nums[l] == nums[l+1]) l++; while(l &lt; r &amp;&amp; nums[r] == nums[r-1]) r--; l++; r--; &#125;else if(sum &gt; target)&#123; r--; &#125;else l++; &#125; &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>双指针法</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode之电话号码的字母组合（17）]]></title>
    <url>%2Fpost%2Fd972dfa3.html</url>
    <content type="text"><![CDATA[题目 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例：12输入："23"输出：["ad", "ae", "af", "bd", "be", "bf","cd", "ce", "cf"]. 说明： 尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。 分析 因为不知道输入数字字符串的长度，考虑用递归实现。注意递归的终止条件。 实现代码：C++123456789101112131415161718192021222324252627282930313233class Solution&#123;public： vector&lt;string&gt; letterCombinations(string digits)&#123; vector&lt;vector&lt;string&gt;&gt; numStrVector = vector&lt;vector&lt;string&gt;&gt;(&#123; &#123;"a","b","c"&#125;, &#123;"d","e","f"&#125;, &#123;"g","h","i"&#125;, &#123;"j","k","l"&#125;, &#123;"m","n","o"&#125;, &#123;"p","q","r","s"&#125;, &#123;"t","u","v"&#125;, &#123;"w","x","y","z"&#125; &#125;); vector&lt;string&gt; res; if(digits.size() == 0)&#123; return res; &#125; vector&lt;string&gt; firstStrVector = numStrVector[digits[0] - 48 - 2]; if(digits.size() == 1)&#123; return firstStrVector; &#125; vector&lt;string&gt; leftStrVector = letterCombinations(digits.substr(1)); for(auto s : firstStrVector)&#123; for(auto left : leftStrVector)&#123; res.push_back(s + left); &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>字符串</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode之最接近的三数之和（16）]]></title>
    <url>%2Fpost%2F8a815e5c.html</url>
    <content type="text"><![CDATA[题目 给定一个包含n个整数的数组nums和一个目标值target。找出nums中的三个整数，使得它们的和与target最接近。返回这三个数的和。假定每组输入只存在唯一答案。12例如，给定数组nums = [-1,2,1,-4],和target = 1.与target 最接近的三个数的和为2.(-1 + 2 + 1 = 2). 思路用双指针法求解 首先对数组进行升序排列（C++ sort默认升序)，然后用数组的前三个元素之和作为预设值，当在数组里确定好第一个数字后，就在剩下的数里找两数之和，再加上第一个数，判断nums[i]+nums[l]+nums[r]与target之差的绝对值是否 &lt;= 预设的三数之和与target的差的绝对值。若是，则更新预设值。然后判断nums[i]+nums[l]+nums[r]与target大小来更新指针，若前者大，说明后指针需要前移，反之，则前指针需要后移。 实现代码：C++123456789101112131415161718192021222324252627282930class Solution&#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums,int target)&#123; int size = nums.size(); int res; if(size &lt; 3)&#123; return res; &#125; sort(nums.begin(),nums.end()); res = nums[0] + nums[1] + nums[2]; for(int i = 0; i &lt; size-2; i++ )&#123; if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1])&#123; continue; &#125; int l = i+1, r = size-1; while(l&lt;r&gt;)&#123; int tempSum = nums[i] + nums[l] + nums[r]; if(abs(tempSum - target) &lt;= abs(res - target))&#123; res = tempSum; &#125; if(tempSum &gt; target)&#123; r--; &#125;else&#123; l++; &#125; &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>双指针法</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode之三数之和（15）]]></title>
    <url>%2Fpost%2F4163df04.html</url>
    <content type="text"><![CDATA[题目 给定一个包含n个整数的nums,判断nums中是否存在三个元素a、b、c，使得1a + b + c = 0 找出所有满足条件且不重复的三元组。 注意: 答案中不可以包含重复的三元组。 123456例如，给定数组 nums = [-1,0,1,2,-1,-4],满足要求的三元组集合为：[ [-1,0,1] [-1,-1,2]] 思路 用双指针法求解。 首先对数组进行升序排列，从第一个数开始遍历，若该数大于0，则无解。否则该数可能满足条件，定义前后两个指针l、r，判断nums[l]+nums[r]+nums[i]是否等于0,若=0,加入解集；若&gt;0，说明nums[l]+nums[r]过大，则向前移动后指针，即r--；反之，说明nums[l]+nums[r]较小，则需要向后移动前指针，即l++。 解决重复问题 由于数组已经升序排列，只需要判断相邻两个数是否相等，如果相等则移动指针。 实现代码：C++12345678910111213141516171819202122232425262728293031323334class Solution&#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums)&#123; vector&lt;vector&lt;int&gt;&gt; res; int size = nums.size(); if(size &lt; 3)&#123; return res; &#125; sort(nums.begin(),nums.end()); for(int i = 0; i &lt; size; i++)&#123; if(nums[i] &gt; 0)&#123; break; &#125; if(i&gt;0 &amp;&amp; nums[i] == nums[i-1])&#123; continue; &#125; int l = i+1,r = size-1; while(l &lt; r)&#123; int sum = nums[i] + nums[l] + nums[r]; if(sum == 0)&#123; res.insert(&#123;nums[i],nums[l],nums[r]&#125;); while(l &lt; r &amp;&amp; nums[l] == nums[l+1]) l++; while(l &lt; r &amp;&amp; nums[r] == nums[r-1]) r--; l++; r--; &#125;else if(sum &lt; 0)&#123; l++; &#125;else r--; &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>双指针法</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode之最长公共前缀（14）]]></title>
    <url>%2Fpost%2Ff9dfb861.html</url>
    <content type="text"><![CDATA[题目 编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串””。 示例112输入： ["flower","flow","flight"]输出： "fl" 示例2123输入： ["dog","racecar","car"]输出： ""解释： 输入不存在公共前缀 说明所有输入只包含小写字母a-z； 实现代码：C++12345678910111213141516171819202122232425262728class Solution&#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs)&#123; int size = strs.size(); if(size == 0)&#123; return ""; &#125; string temp; bool flag = false; for(int j = 0; j &lt; strs[0].size(); j++)&#123; char t = strs[0][j]; for(int i = 0; i &lt; size; i++)&#123; if(strs[i][j] != t || strs[i][j == '\0'])&#123; flag = true; break; &#125; &#125; if(flag)&#123; break; &#125; temp.push_back(t); &#125; return temp; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之Bridge模式]]></title>
    <url>%2Fpost%2F2af670e6.html</url>
    <content type="text"><![CDATA[Bridge 模式存在之意图:“将抽象与现实解耦，使它们可以独立地变化”。 Bridge 模式是最难理解的模式，部分原因是它功能非常强大，适用于多种场合。而且，它还与常见的用继承来处理特殊情况的方式背道而驰。但是，它却是一个遵循设计模式社区两大原则的极好例子：“找出变化并封装之”和“优先使用对象聚集，而不是类继承”。 需求特点： 概念的抽象有变化； 这些概念的实现方式有变化。 要点：在需求定义期间，应该尽早而且经常地考虑变化。 UML类图如下： 问题：一个抽象类的派生类必须使用多个实现，但它不能出现类数量爆炸性增长。 解决方案：为所有实现定义一个接口，供抽象类的所有派生类使用。 参与者与协作者：Abstraction为要实现的对象定义接口，Implementor为具体的实现类定义接口。Abstraction的派生类使用Implementor的派生类，却无需知道自己具体使用哪一个ConcreteImplementor。 效果：实现与使用实现的对象解耦，提供了可扩展性，客户对象无需操心实现问题。 代码示例：假设目前有这么几个类:GoogleTV 和 AppleTV,都能实现换台，与开关电视等基本功能，但是并没有一个统一的接口，用户其实也不care你用的是哪个TV，用户只是单纯想看芒果台而已。现在使用Bridge模式实现这个需求。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public interface TV&#123; public void powerON(); public void powerOff(); public void changeChannel(int channel);&#125;public class GoogleTV implements TV&#123; public void powerOn()&#123;&#125; public void powerOff()&#123;&#125; public void changeChannel(int channel)&#123;&#125;&#125;public class AppleTV implements TV&#123; public void powerOn()&#123;&#125; public void powerOff()&#123;&#125; public void changeChannel(int channel)&#123;&#125;&#125;public abstract class TVRemoteControl&#123; private TV tv; public void setTV(TV tv)&#123; this.tv = tv; &#125; public TV getTV()&#123; return this.tv; &#125; public void powerOn()&#123; implementor.powerOn(); &#125; public void powerOff()&#123; implementor.powerOff(); &#125; public void setChannel(int channel)&#123; implementor.changeChannel(channel); &#125;&#125;public class ConcreteTVRemoteControl extends TVRemoteControl&#123; private int currentChannel; public void nextChannel()&#123; currentChannel++; setChannel(currentChannel); &#125; public void prevChannel()&#123; currentChannel++; setChannel(currentChannel); &#125;&#125;public class BridgeTest &#123; public static void main(String[] args) &#123; TVRemoteControl tvBridge = new TVRemoteControl(); /*使用google TV */ GoogleTV googleTV = new GoogleTV(); tvBridge.setTV(googleTV); tvBridge.setChannel(3); /*使用 Apple TV */ GoogleTV googleTV = new GoogleTV(); tvBridge.setTV(googleTV); tvBridge.setChannel(3); &#125;&#125; 可结合 Strategy、 Adapter 模式来看。]]></content>
      <categories>
        <category>编程思想</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之Proxy模式]]></title>
    <url>%2Fpost%2Fae91a8e6.html</url>
    <content type="text"><![CDATA[Proxy 模式意图 为其他对象提供一种代理以控制对这个对象的访问。 动机 对一个对象进行访问控制的一个原因是为了只有在我们确实需要这个对象时才对它进行创建和初始化。 应用场景 代理模式主要用于当我们需要一个简单对象来表示一个复杂对象的情形。如果创建对象的开销很大，那么可以==推迟其创建==，并使用一个简单对象来代理其功能直到必须立即创建的时候。这个简单对象就可以称为复杂对象的代理。 UML类图如下： 参与者与协作者： 抽象角色（Subject）：它是一个由真实角色实现的接口，并能够表征真实角色的功能。该接口同时也必须由代理角色实现，这样代理角色能够用于所有真实角色所能使用的地方。 代理角色（Proxy）：它维护了能够允许代理角色访问真实角色的引用。代理角色与真实角色都实现了同一个接口，这样代理角色就能代替真实角色，实现对真实角色的访问控制并负责数据的创建和删除。根据代理的类型，其还能负责其他的职责。 真实角色（RealSubject）：这是代理角色所代表的真实对象。 代码示例:假如我们想要在电子邮件中附加一张图片。而添加一张照片并发送是一件耗费大量资源的操作。 这时我们使用代理模式，让我们能够在确实需要加载图片时才对它进行创建和初始化。 首先，我们创建一个能够被真实对象和代理对象实现的通用接口 123public interface Image &#123; void showImage();&#125; 建立一个真实图片类实现上述接口 123456789101112131415161718public class RealImage implements Image &#123; private URL url; public RealImage(URL url)&#123; this.url = url; loadImage(url); &#125; @Override public void showImage() &#123; System.out.println("Displaying " + url.getFile()); &#125; private void loadImage(URL url)&#123; System.out.println("Loading " + url.getFile()); &#125;&#125; 编写代理类，提供对真实图片类的访问。 1234567891011121314151617public class ProxyImage implements Image&#123; private RealImage realImage; private URL url; public ProxyImage(URL url)&#123; this.url = url; &#125; @Override public void showImage() &#123; if(realImage == null)&#123; realImage = new RealImage(url); &#125; realImage.showImage(); &#125;&#125; 测试 123456789101112public class ProxyTest &#123; public static void main(String[] args) &#123; Image image = new ProxyImage(new URL("test.jpeg")); // 加载图片 image.showImage(); System.out.println(""); // 图像加载过，则不需再次加载 image.showImage(); &#125;&#125;]]></content>
      <categories>
        <category>编程思想</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fpost%2F4a17b156.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hhhh</category>
      </categories>
      <tags>
        <tag>hh</tag>
      </tags>
  </entry>
</search>
